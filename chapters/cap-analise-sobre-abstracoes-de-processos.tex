\chapter{Analise Sobre Abstrações de Processos}
\label{cap:analise-sobre-abstracoes-de-processos}

No Capítulo \ref{cap:trabalhos-analisados} introduzimos os principais trabalhos
que orbitam sobre o tema de novas abstrações de processos para que nesse
capítulo seja feito uma reflexão cuidadosa sobre as principais características
de tais pesquisas. No decorrer deste o capítulo realizamos diversas analises
sobre o estado da arte dos diferentes trabalhos e apresentamos um modelo
teórico que visa apresentar uma perspectiva para a nova geração de abstrações
de processos.  Esse capítulo responde as seguintes perguntas de pesquisa:

\begin{quote}
 \item \textit{RQ1:.} "Quais são as características desejáveis para a próxima geração de abstrações de processos?"
 \item \textit{RQ2:.} "Quais são os principais desafios em se implementar a próxima geração de abstrações de processos?"
\end{quote}

Um dos principais diferenciais desse trabalho, consiste em considerar o uso de
novas extensões nas abstrações de processos levando em consideração SOs de uso
cotidiano, em especial o GNU/Linux. Esse critério é importante, pois
acreditamos que se tais abstrações chegarem até os SOs de ampla utilização,
novos ramos de pesquisa surgiram.

\section{Potenciais e dificuldades para adotar novas abstrações de processos}
\label{sec:potenciais}

Pesquisas em SO buscam avançar o estado da arte, contudo, SOs
usados em produção e em projetos de pesquisa possuem diferentes restrições. Se uma
nova proposta feita pela academia tem por objetivo ser utilizada em aplicações
que estão no estado da prática, essas devem considerar questões referentes
a compatibilidade, melhor uso do hardware atual, confiabilidade e ser genérico
o bastante para ser utilizado por múltiplas linguagens de programação.

Os SOs usados em produção demandam rigorosa validação para manter o sistema
estável em uma variedade de configurações, como prevenir acesso ilegal a
memória, impossibilitar violação de API, evitar consumo excessivo de recursos e
impedir erros de sincronização ou \textit{locking}. Essas características tem
que ser garantidas pelo SO \citep{mondrix}, como pode-se esperar, tais
restrições são complicadas de atendidas por propostas de pesquisas que
normalmente concentram-se em um único problema sem considerar outros impactos.
Por esses motivos, para que um novo componente sugerido por meio de pesquisa
chegue aos SOs atuais, é importante garantir que as aplicações que já existem
não sofram impactos negativos em termos de desempenho e de uso.

Outra perspectiva que deve ser considerada é o contínuo desenvolvimento de novos
recursos de hardware, por exemplo, é comum observar componentes que
são especializados em um nicho e que ao longo do tempo chegam ao usuário
final tornando-se comum. Um caso simples que ilustra tal evolução é o
uso de hardware especializado para virtualização, uma vez que esses existiam
apenas para servidores e hoje estão disponíveis para a maioria dos usuários
comuns. Tais recursos representam um novo leque de opções não exploradas,
inclusive para trazer melhorias para as atuais abstrações de processos.
Entretanto, qualquer tentativa de incorporar os novos recursos de hardware para
a abstração de processos deve levar em consideração que alguns usuários podem
não ter tal recurso disponível. Por essa razão qualquer mudança nos processos
que adicionem suporte a novos recursos de hardware devem levar em consideração
todo tipo de caso. De modo inverso, propostas para melhorar uma abstração de
processos podem sugerir mudanças no hardware sendo útil para avançar os
estado da arte dos chips modernos. Claro que a evolução do hardware deve ser
cuidadosa para evitar quebrar a compatibilidade binária com aplicações legadas.
Infelizmente, é preciso ter em mente que alteração de hardware e suas
limitações faz com propostas que dependem de tal evolução sejam difíceis de
serem adotadas e fazem com que a ampla adoção de uma determinada melhoria seja
impraticável.

Algumas das novas abstrações de processos propostas por alguns pesquisadores
tem enorme dependência com outras tecnologias experimentais. Se por um lado
isso traz vantagens para as tecnologias em desenvolvimento, por outro reduz a
chance de uma nova abstração de processos ser adotada por um SO de produção
devido a dependência em tecnologias instáveis.

% TODO: Verificar a explicação da tabela uma vez que essa sofrerá alterações
Um nova proposta de mudança em abstrações de processos devem analisar
cuidadosamente as limitações citadas para que possam atender aos requisitos de
qualidade exigidas por SO de uso cotidiano. Nesse sentido, é preciso encontrar
um equilíbrio entre a pesquisa e desenvolvimento, ou seja, um balanceamento
estre academia e a industria de forma a encontrar soluções que levem benefícios
para os usuários. A Tabela \ref{tab:adocao} qualifica o potencial de adoção de
cada uma das propostas citadas no Capítulo \ref{cap:trabalhos-analisados} de
acordo com as considerações feitas nessa seção. A tabela marca em uma escala de
zero até cinco a possibilidade de uma determinada proposta ser adotada por SOs
de produção.

\input{tables/potencial_adocao}

\section{Extraído conceitos derivados das pesquisas em abstrações de processos}

Todas as pesquisas apresentadas no Capítulo \ref{cap:trabalhos-analisados}
representam o estado da arte no que se refere as abstrações de processos,
infelizmente nenhuma delas encontra-se no código principal de nenhum SO de uso
cotidiano. Parte desse problema vem dos fatos apresentados na Seção
\ref{sec:potenciais}, contudo outros aspectos que contribuem para que tais
propostas não estejam presentes nos SO modernos vem da falta de unificação e
sistematização de tais ideias. Ao analisar cada uma das propostas, notamos que
todas elas propõem direta ou indiretamente algum nível de desacoplamento entre
os elementos presentes no SO. Tal observação nasce da abordagem radical tomada
pelos criadores do Exokernel, que levaram o nível de desacoplamento do SO ao
extremo. Apesar do Exokernel ser um sistema difícil de ser adotado em termos
práticos, esse nos alerta sobre as vantagens em se reduzir as dependências
entre os elementos do SO e as possibilidades que isso pode levar ao espaço de
usuário. Nesse sentido revisitamos de forma breve alguns dos trabalhos
apresentados no Capítulo \ref{cap:trabalhos-analisados} sob a ótica do
desacoplamento e seus potenciais benefícios.

O projeto Dune traz uma nova perspectiva de uso dos recursos de virtualização
disponibilizados pelas CPUs modernas, consequentemente esse traz dois
benefícios diretos: otimização e flexibilidade. Ao utilizar os recursos de
virtualização para acelerar certas tarefas, o Dune promoveu avanços em um setor
difícil de ser otimizado. Além disto, tais melhorias facilitam certas
implementações no espaço de usuário, pois removem a necessidade de códigos com
técnicas avançadas que visam trazer melhorias de desempenho; em outras
palavras, a proposta do Dune pode melhorar a legibilidade de alguns códigos.
Todos esses avanços são factíveis graças ao \textbf{desacoplamento da
virtualização}, que por sua vez possibilita entregar melhor desempenho no
espaço de usuário de maneira relativamente simples do ponto de vista da
aplicação e também entregam benefícios de segurança.

Já o projeto Nooks se distância um pouco da abstração de processos uma vez que
ele busca tornar o núcleo do SO mais resiliente. Contudo, ao criar mecanismos
que reagem de forma a reduzir as chances do sistema quebrar, o mesmo apresenta
uma proposta de \textbf{desacoplamento dos recursos} de forma a fornecer
mecanismos para que os processos possam se recuperar ou tomar ações em casos de
falhas.  Adicionalmente, tal técnica também cria um interessante mecanismo de
comunicação entre as extensões do Kernel e os seus drivers que permite o SO se
proteger de problemas que aconteceu com um código que foi acoplado ao seu
núcleo.

De forma mais direta e sistemática o \textit{Resource Container} sugere o
controle fino do gerenciamento de recursos e consequentemente o desacoplamento
de tal elemento. De certa forma, tal proposta já pode ser vista incorporado nos
SOs atuais, na forma dos containers no Linux, mais especificamente, como o
\textit{cgroups}. A principal contribuição do trabalho, vem da sua capacidade
de permitir que a própria aplicação tome conta da sua execução.  Vale observar
que ainda que parte das ideias apresentada por essa pesquisa estejam presentes
em alguns SOs, as implementações ainda são relativamente reduzidas em termos de
escopo do ponto de vista da pequisa apresentada.

Uma abordagem alternativa que visa atender uma nova geração de computadores com
memórias não voláteis e que são da ordem dos petabytes é o SpaceJMP/MVAS.  Os
autores sugerem \textbf{desacoplar o VAS dos processos} e permitir que esses
tenham múltiplas VAS e de forma reativa, a aplicação torne-se capaz de mudar o
VAS atual. Essa abordagem faz com que um processo consiga acessar regiões muito
maiores do que aquelas garantidas pelo tamanho de uma VAS. Indiretamente
desacoplar uma VAS adiciona a possibilidade de criar processos persistentes,
isto é, que vivem mesmo após o boot ou mesmo após um problema. Desacoplar a VAS
pode trazer benefícios para aplicações de \textit{checkpoints}, melhorar o
gerenciamento de bibliotecas, isolamento e compartilhamento.

O Light-weight Context (lwC) indiretamente propõe o total
\textbf{desacoplamento do PC}, vale observar que os autores explicitam outros
desacoplamentos, contudo, para esse trabalho acredita-se que o desacoplamento
do PC é o que melhor descreve as inovações propostas. Desacoplar o PC leva uma
infinidade de possibilidade para o espaço de usuário uma vez que o processo
pode fazer operações semelhantes ao do escalonador, sem grandes custos, e
dentro do mesmo intervalo de execução do processo. O lwC tem como principal
característica um robusto e interessante modelo de programação que permite
aplicações no espaço de usuário utilizarem novos paradigmas de desenvolvimento.
Isso cria diversas oportunidades que novos tipos de manipulações sejam
possíveis, tal como criar \emph{snapshot} do atual estado do processo e depois
reverter o processo para o estado anterior. Outra possibilidade é mudar para um
novo contexto de processo com acesso restrito para alguma região da memória
antes da execução de um código sensível. Isso não é como utilizar threads ou
processos independentes, mas ao invés de depender do escalonador para mudar o
contexto do processo (que é razoavelmente caro) a própria aplicação por si
mesmo pode escolher quando e qual contexto manipular, levando assim um controle
fino para os programadores que pode melhorar o desempenho e a segurança. Note
que o escalonador não ainda existe, a troca de contexto no lwC acontece dentro
do intervalo de tempo fornecido pelo escalonador.

Vários dos trabalhos analisados, tem preocupação com o gerenciamento e acesso a
memória; em especial, vários deles questionam o tratamento dado a memória pelos
SOs atuais.  A abordagem de utilizar um único espaço de endereçamento por
processo tem se provado eficiente ao longo dos anos, contudo, apesar do seu
sucesso, essa não é uma abordagem a prova de falhas e ainda precisa receber
melhorias.  Primeiramente, a abordagem de isolar os processos por meio do
espaço de endereçamento linear melhora a confiabilidade do sistema e a
segurança.  Contudo, um processo não tem uma forma de restringir o seu próprio
acesso ao seu segmento de memória que pode ser útil para reduzir os riscos de
falhas de segurança ocasionados por binários de terceiros. Em segundo lugar, o
controle do compartilhamento de memória acontece no tamanho de uma página e
cria a oportunidade para explorar falhas, tais quais \emph{buffer e stack
overflow} ou mesmo o compartilhamento de bibliotecas comprometidas. Os
trabalhos Wedge, shreds e mondrix/mondrian buscam trazer melhorias nessa área.

Observando as abstrações de processos da perspectiva da segurança, o projeto
Wedge retoma uma antiga premissa que defende o princípio do menor privilégio.
Esse justifica que precisamos mudar a lógica atual de dar permissão para tudo,
para uma ideia de negar permissão por padrão. Essa mudança de paradigma torna
possível, supostamente, reduzir as chances de ataques e vazamento de dados uma
vez que o programador precisa indicar explicitamente o que será exposto. Tal
pesquisa, indiretamente propõe o \textbf{desacoplamento dos privilégios} da
abstração de processos . Além disso, ela mantém a compatibilidade entre
aplicações novas e legadas uma vez que é uma opção que o programador pode optar
por usar ou não.

Entrando um pouco mais nas questões de proteção e controle-fino da memória,
destacamos o shreds e o mondrix/mondrian. O shreds nasce com a ideia de evitar
ataques conhecidos como abusos intra-processos de conteúdo da memória.  Os
autores defendem que o acesso a certas regiões da memória do processo
executando em espaço de usuário merecem proteção de acesso. Em tal proposta, os
autores utilizaram um recurso especifico dos processadores ARM em conjunto com
um mecanismo de gerenciamento da região de memória (Seção
\ref{sec:outros_mecanismos_memoria}). Essa proposta entrega mais flexibilidade,
segurança, e controle ao acesso da memória.

Na mesma linha de fornecer controle fino sobre a memoria, os autores do Mondrix
propuseram de forma mais radical um mecanismo de controle do acesso a memória
ao nível das palavras de dados. Para isso, os autores sugeriram alterações no
hardware e do SO de forma a controlar todo acesso com a menor granularidade
possível. Indiretamente, o shreds e o mondrix são propostas de
\textbf{desacoplamento do controle de memória}.

\section{Atomize: Um modelo teórico para a próxima geração de abstrações de processos}

A principal contribuição desse trabalho consiste em analisar os impactos do
desacoplamento das abstrações de processos em SOs modernos. Nesse sentido
observamos e analisamos diferentes propostas de desacoplamento que ainda
consistem no estado da arte, acreditamos várias das ideias apresentadas podem
atingir o estado da prática pavimentando novos ramos de pesquisas. Como
resultado dessa pesquisa, compilamos os diversos trabalhos estudados em um
modelo que busca um maior grau de desacoplamento dentro das abstrações de
processos.

Para exemplificar a proposta de desacoplamento deste trabalho, faremos uma
analogia com a evolução do modelo atômico. Começamos por um dos primeiros
modelos atômicos aceito pela comunidade cientifica proposto por Dalton, esse
afirmava que um atamo era uma esfera maciça e indivisível. Em seguida, Thomson
propôs outro modelo no qual os átomos eram compostos por partículas positivas e
negativas indicando a divisibilidade dos átomos. Posteriormente, Rutherford
refinou o modelo propondo um esquema em que o átomo possui um núcleo e os
elétrons giram em torno desse núcleo formando um sistema semelhante ao modelo
planetário. O modelo atômico continua evoluindo e se sofisticando cada vez
mais, contudo a principal lição que tiramos disso para o nosso contexto é o
constante refinamento do modelo e os avanços que junto com ele.

Seguindo a analogia do modelo atômico, podemos considerar que as abstrações de
processos estão em um estágio equivalente ao modelo de Thomson. A abstração de
processo não é mais um bloco sólido e indivisível, essa possui um leve grau de
desacoplamento uma vez que no passado notou-se a vantagem em se desacoplar o PC
e a Stack possibilitando múltiplos fluxos de execução no mesmo processo
(threads). Seguindo esse raciocínio e buscando avançar o modelo atual,
apresentamos o \textbf{atomize} que consiste em um modelo que busca um elevado
grau de desacoplamento dos elementos da abstração de processos.

Como apresentado na Seção \ref{sec:potenciais}, para que os desacoplamentos
propostos nas pesquisas sejam absorvidos pelos SOs atuais é preciso considerar
diversos aspectos. Em especial destacamos que a as abordagens que seguem uma
implementação leve e que atendem as propostas de desacoplamento destacadas na
Tabela \ref{tab:desacoplamento_beneficio} são preferíveis. A tabela mostra as
propostas de desacoplamento na vertical e os benefícios que essas podem trazer
aos SOs. Por fim, utilizamos uma escala de zero a três \ding{52} que indica o
quanto de benefício um determinado desacoplamento pode levar para uma área.

\input{tables/desacoplar_beneficios}

A Figura \ref{fig:decomposicao_proc} busca mostrar de forma visual o modelo de
abstração de processos proposto por esse trabalho. Na parte central da figura
temos os três elementos fundamentais para o uso dos processos: PC, Stack e IO
context. De forma mais externa temos a VAS, essa é um elemento importante para
que os processos em SOs de proposito geral funcionem de forma apropriada. Em
seguida notamos diversos elementos que orbitam a abstração atual de processos e
que podem ser vistos como elementos menos importantes para o correto
funcionamento da abstração, mas que são fundamentais para a diversas aplicações
modernas.

\begin{figure}[!h]
  \centering
  \includegraphics[width=\textwidth]{decomposicao}
  \caption{Decomposição do processo}
  \label{fig:decomposicao_proc}
\end{figure}

Em termos de API e implementação, queremos manter os critérios para adoção
descritos na Seção \ref{sec:potenciais} e ao mesmo tempo fornecer uma poderosa
API que possa ser utilizada no espaço de usuário. Para que tal modelo possa ser
implementado é preciso usar uma abordagem que caminha entre uma "implementação
estrutural leve e pesada". Implementação pesada, pois será necessário inserir
intermediários nas atuais abstrações de processo de forma a fornecer elementos
para que outros mecanismos externos atuem sobre o processos e ainda assim
manter a compatibilidade com as aplicações já existentes (não queremos forçar
mudanças nas aplicações no espaço do usuário). Implementação leve, pois
queremos o maior grau de desacoplamento possível e também facilitar futuras
expansões no modelo.

\input{algorithm/snapshot}

Como mostrado no Capitulo \ref{cap:trabalhos-analisados}, cada proposta de
extensão da abstração de processo sugere uma API para o seu contexto
específico. Nesse sentido, a Tabela \ref{tab:ops_atomize} busca centralizar as
principais chamadas para o atomize de forma genérica. A tabela é composta por
uma coluna indicando um constante para a operação, seguida do trabalho na qual
foi derivada e uma breve descrição sobre o seu comportamento. Note que o
conjunto dessas operações pode ser abstraída para uma biblioteca no espaço do
usuário e que a combinação das várias operações abre um leque de novas
possibilidades no espaço de usuário. Para ilustrar possível implementação do
atomize, na próxima subseção discutimos uma alternativa para implementar tal
conceito em no GNU/Linux.

\input{tables/atomize_ops}

\subsection{Atomize como subsistema no GNU/Linux}

Uma alternativa para implementar o atomize em um sistema GNU/Linux é fazê-lo
como um novo subsistema na forma de um driver (Veja Seção \ref{sec:dd}). Para
isto seria necessário ter uma API de chamadas via IOCTL que executa operações
de acordo com o código passado. Normalmente, quando existe um grande número de
operações definidas via IOCTL é desejável a criação de uma biblioteca no espaço
do usuário que facilite a manipulação das operações e que forneça mecanismos
para facilitar o seu uso. Dessa forma, inspirado na Tabela X apresentamos a
Tabela \ref{tab:ops_atomize} ilustrando as operações de IOCTL e a função que
manipula a mesma no espaço de usuário.

\input{tables/atomize_ops_linux}

Um dos problemas na implementação da abstração de processos no GNU/Linux
deve-se ao seu elevado acoplamento. Nesse sentido, só implementar o novo
subsistema no Kernel Linux não resolveria o problema. Seria preciso implementar
funções intermediarias nos processos do Linux de forma a fornecer os devidos
mecanismos para que o driver possa executar as ações solicitadas pelo espaço de
usuário. Uma abordagem, pode ser a de atualizar a estrutura de dados referentes
aos processos e inserir funções que interceptem a execução do processo durante
a sua criação.

% TODO: Discutir aplicações
